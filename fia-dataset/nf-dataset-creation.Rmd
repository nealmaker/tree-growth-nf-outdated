---
title: "An FIA dataset for modeling tree-level changes in the Northern Forest"
author: "Neal Maker"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  pdf_document:
    fig_caption: TRUE
    df_print: kable
---

```{r, setup, include=FALSE}
# knitr::opts_chunk$set(echo = T, error = T, warning = T, message = T, 
#                       strip.white = F, tidy.opts = list(width.cutoff = 60))
knitr::opts_chunk$set(echo = FALSE, error = FALSE, warning = FALSE, 
                      message = FALSE)
```

# Introduction

The intent of this project is to put together a dataset of remeasured trees from the US Forest Service's Forest Inventory and Analysis (FIA) records for the Northern Forest region, which will allow tree-level changes to be modeled accurately. Specifically, the dataset should support the development of unbiased models of dbh increment, height, height increment, crown ratio increment, and survival; and the determination as to which variables are the most important predictors of those outcomes. Potential predictors to be kept in the dataset are those that (1) are widely available in the FIA data in the region (to maintain large sample sizes), and (2) can be recorded in forest inventories or remotely without large increases in inventory costs.

The Northern Forest region was chosen because it covers a fairly large geographic extent while still representing a coherent ecological region, in which trees can be expected to follow a similar set of behaviors. Models developed with the dataset should be relatively unbiased for individual forests within the region, but will still allow for streamlined analyses across disparate ownerships. The US Northern Forest is defined here as including Oswego, Oneida, Lewis, Jefferson, Saint Lawrence, Herkimer, Fulton, Hamilton, Franklin, Essex, Clinton, and Warren Counties in New York; Franklin, Orleans, Essex, Chittenden, Lamoille, Caledonia, Washington, Addison, Orange, and Grand Isle Counties in Vermont; Coos, Grafton, and Carroll Counties in New Hampshire; and Oxford, Franklin, Somerset, Androscoggin, Kennebec, Waldo, Hancock, Washington, Penobscot, Piscataquis, and Aroostook Counties in Maine.

```{r region}
library("tidyverse")
library("lubridate")
library("english")

# Define States & counties (FIPS codes) in Northern Forest region --------

states <- c("NY", "VT", "NH", "ME")

NY_counties <- c(75, 65, 49, 45, 89, 43, 35, 41, 33, 31, 19, 113)
VT_counties <- c(11, 19, 9, 7, 15, 5, 23, 1, 17, 13)
NH_counties <- c(7, 9, 3)
ME_counties <- c(17, 7, 25, 1, 11, 27, 9, 29, 19, 21, 3)
```

# Methods

FIA data were downloaded from the FIA DataMart^[https://apps.fs.usda.gov/fia/datamart/datamart.html] in the form of state-specific csv files, which were generated by the Forest Service from the FIA Oracle database tables. These data are current as of `r format(Sys.Date(), format = "%B %d, %Y")`. In the future, the dataset can be re-built using updated csv files to incorporate new remeasurement data.

```{r fetch}
################################################################################
# Import FIA data
################################################################################

# Fetch FIA tree, growth, plot, & condition data for Northern Forest states 
# and filter to keep only northern forest counties
# (this may take a while; ~140MB of downloads + reading)

temp <- tempfile()

for(state in states){
  download.file(paste("https://apps.fs.usda.gov/fia/datamart/CSV/", 
                      state, "_TREE.zip", sep = ""),
                temp, mode = "wb")
  unzip(temp, paste(state, "_TREE.csv", sep = ""))
}

TREE <- lapply(states, function(x){
  read.csv(paste(x, "_TREE.csv", sep = ""), header = T) %>% 
    filter(COUNTYCD %in% eval(as.name(paste(x, "_counties", sep = ""))),
           DIAHTCD == 1) %>% # excludes seedlings measured at root collar
    select(CN, PLT_CN, SUBP, PREV_TRE_CN, CONDID, DIA, SPCD, STATUSCD, 
           MORTYR, CR, CCLCD, TREECLCD, HT) %>%
    mutate(ba_ac = if_else(DIA >= 5, 
                           # poles & larger from 24' radius subplots
                           # saplings from 6.8' radius microplots
                           0.005454*DIA^2*(43560/(pi*24^2)),  
                           0.005454*DIA^2*(43560/(pi*6.8^2)))) 
})

## SUBPLOTS MATTER!!!!
# Subplots may have different sizes depending on the plot design, found in 
# PLOT$DESIGNCD (see database guide, appendix i)
# I can just keep DESIGNCD == 1 (the main standard) and lose some data, 
# or I can account for the various designs when I calculate TREE$ba_ac
# (above; which would mean calculating ba_ac after combining
# states' data and joining nf_trees to nf_plots).
# Update: it's probably harder b/c they severed the plot codes to older 
# inventories to keep people from seeing real coordinates

# DESIGN CODES:
# 1:4 used 1999 - present
# 11:15 used 1994 - 1996
# 100 used 1982 & 1983
# 101:104 used 1991 - 1998
# 101 was continued through 2008
# 105:120 variousy used 1991 - 1993


for(state in states){
  download.file(paste("https://apps.fs.usda.gov/fia/datamart/CSV/", state, 
                      "_PLOT.zip", sep = ""),
                temp, mode = "wb")
  unzip(temp, paste(state, "_PLOT.csv", sep = ""))
}

PLOT <- lapply(states, function(x){
  read.csv(paste(x, "_PLOT.csv", sep = ""), header = T) %>% 
    filter(COUNTYCD %in% eval(as.name(paste(x, "_counties", sep = "")))) %>% 
    select(CN, PREV_PLT_CN, DESIGNCD, MEASYEAR, MEASMON, 
           MEASDAY, LAT, LON, ELEV) %>%
    rename(PLT_CN = CN)
})


for(state in states){
  download.file(paste("https://apps.fs.usda.gov/fia/datamart/CSV/", state, 
                      "_COND.zip", sep = ""),
                temp, mode = "wb")
  unzip(temp, paste(state, "_COND.csv", sep = ""))
}

COND <- lapply(states, function(x){
  read.csv(paste(x, "_COND.csv", sep = ""), header = T) %>% 
    filter(COUNTYCD %in% eval(as.name(paste(x, "_counties", sep = "")))) %>% 
    select(PLT_CN, CONDID, FORTYPCD, ALSTKCD, SITECLCD, 
           PHYSCLCD, SLOPE, ASPECT)
})


for(state in states){
  download.file(paste("https://apps.fs.usda.gov/fia/datamart/CSV/", state, 
                      "_TREE_GRM_COMPONENT.zip", sep = ""),
                temp, mode = "wb")
  unzip(temp, paste(state, "_TREE_GRM_COMPONENT.csv", sep = ""))
}
  
GRM <- lapply(states, function(x){
  read.csv(paste(x, "_TREE_GRM_COMPONENT.csv", sep = ""), header = T) %>% 
    filter(!is.na(ANN_DIA_GROWTH)) %>% 
    select(TRE_CN, STATECD, DIA_BEGIN, DIA_MIDPT, DIA_END, ANN_DIA_GROWTH,
           HT_BEGIN, HT_MIDPT, HT_END, ANN_HT_GROWTH)
})

# Combine states' data

nf_trees <- do.call(rbind, TREE)
nf_plots <- do.call(rbind, PLOT)
nf_conds <- do.call(rbind, COND)
nf_grms <- do.call(rbind, GRM)

# delete temporary objects and downloaded files

unlink(temp)

remove(TREE, PLOT, COND, GRM, temp, state)

for(state in states){
  file.remove(paste(state, "_TREE.csv", sep = ""))
  file.remove(paste(state, "_PLOT.csv", sep = ""))
  file.remove(paste(state, "_COND.csv", sep = ""))
  file.remove(paste(state, "_TREE_GRM_COMPONENT.csv", sep = ""))
}
```

Records for individual trees were joined to plot and condition data to add site and stand attributes, and data from remeasured plots were joined to data from previous inventories to add starting and ending measurements. Records for trees without remeasurement data were discarded, along with records for trees that were already dead at their starting measurement, trees that were incorrectly inventoried during starting or ending inventories, and seedlings with diameters measured at the root collar instead of at breast height. FIA plot designs varied in the past in different years and locations, and we only used inventories that employed the current, standard plot design. This design started being used in the mid 1990s, and allows easy comparison between inventories from different times and places. 

Some of the variables retained from the FIA tables were recorded in the field, while others were determined remotely by the FIA Program. We also calculated a number of variables ourselves after the fact. These include plot basal area and tree overtopping basal area, which we calculated by grouping trees into their respective plots and subplots; species-specific plot basal area and overtopping basal area; and diameter, height, and crown ratio growth rates, which we calculated using remeasurement data. Diameter and height growth rates are also reported in the FIA database, but the FIA Program estimates diameter rates using a model instead of calculating them from the remeasurement data, making them unsuitable for training new models. 

```{r bal}
################################################################################
# Group species
################################################################################

# Make names and factor levels more intuitive ------------------------------

species_codes <- 
  c(12, 43, 68, 70, 71, 91, 94, 95, 96, 97, 105, 123, 125, 126, 129, 
    130, 136, 202, 221, 241, 261, 310, 313, 314, 315, 316, 317, 318, 
    319, 320, 331, 341, 355, 356, 357, 367, 370, 371, 372, 373, 375, 
    379, 391, 400, 402, 403, 407, 409, 421, 462, 491, 500, 531, 540, 
    541, 543, 544, 546, 552, 601, 602, 621, 651, 655, 660, 661, 663, 
    680, 693, 701, 712, 731, 741, 742, 743, 744, 746, 760, 761, 762, 
    763, 764, 771, 802, 804, 806, 816, 823, 832, 833, 837, 901, 920, 
    922, 923, 926, 934, 935, 936, 937, 950, 951, 970, 972, 975, 977, 
    999)

species <- 
  c("fir", "other softwood", "cedar", "tamarack", "tamarack", 
    "norway spruce", "spruce", "spruce", "spruce", "spruce", "other softwood", 
    "other softwood", "red pine", "other softwood", "white pine", "scots pine", 
    "other softwood", "other softwood", "other softwood", "cedar", "hemlock", 
    "other hardwood", "soft maple", "hard maple", "striped maple", "soft maple",
    "soft maple", "hard maple", "other hardwood", "hard maple", 
    "other hardwood", "other hardwood", "other hardwood", "other hardwood", 
    "other hardwood", "other hardwood", "other hardwood", "yellow birch", 
    "other hardwood", "other hardwood", "paper birch", "other hardwood", 
    "other hardwood", "hickory", "hickory", "hickory", "hickory", "hickory", 
    "other hardwood", "other hardwood", "other hardwood", "other hardwood", 
    "beech", "ash", "ash", "ash", "ash", "ash", "other hardwood", "butternut", 
    "other hardwood", "other hardwood", "other hardwood", "other hardwood", 
    "other hardwood", "other hardwood", "other hardwood", "other hardwood", 
    "other hardwood", "hophornbeam", "other hardwood", "other hardwood", 
    "aspen", "cottonwood", "aspen", "cottonwood", "aspen", "other hardwood", 
    "other hardwood", "black cherry", "other hardwood", "other hardwood", 
    "other hardwood", "white oak", "white oak", "red oak", "white oak", 
    "white oak", "white oak", "red oak", "red oak", "other hardwood", 
    "other hardwood", "other hardwood", "other hardwood", "other hardwood", 
    "other hardwood", "other hardwood", "other hardwood", "other hardwood", 
    "basswood", "basswood", "elm", "elm", "elm", "elm", "other hardwood")

names(species) <- as.character(species_codes)

nf_trees$SPCD <- factor(unname(species[as.character(nf_trees$SPCD)]),
                     levels = levels(factor(species))) # standardize levels



################################################################################
# Calculate BAL & plot BA for each tree
################################################################################

# Calculates overtopping basal area (BAL) assuming all input trees are in 
# same plot and ba is adjusted based on tpa:
pbal <- function(dbh, ba){
  sapply(dbh, function(x){
    index <- dbh > x
    return(sum(ba[index]))
  })
}


# Add BAL
nf_trees <- nf_trees %>%
  mutate(bal = NA,
         ba = NA)

# Note that this only calculates ending basal areas for trees that lived
nf_trees[nf_trees$STATUSCD == 1,] <- nf_trees[nf_trees$STATUSCD == 1,] %>% 
  group_by(PLT_CN, SUBP) %>% 
  mutate(bal = pbal(DIA, ba_ac),
         ba = sum(ba_ac, na.rm = T)) %>% 
  ungroup()


################################################################################
# Calculate species-specific BAL & plot BA for each tree
################################################################################

# BA ---------------------------------------------------------------------------
sppba <- lapply(levels(nf_trees$SPCD), function(i) {
  temp <- nf_trees %>% 
    group_by(PLT_CN, SUBP) %>% 
    mutate(sppba = sum(ba_ac[SPCD == i & STATUSCD == 1])) %>% 
    ungroup()
  return(temp$sppba)
})

temp <- as.data.frame(do.call(cbind, sppba))
names(temp) <- str_replace(paste0("ba_", levels(nf_trees$SPCD)), " ", ".")
nf_trees <- cbind(nf_trees, temp)


# BAL --------------------------------------------------------------------------

# Calculates overtopping basal area (BAL) of one species only, assuming all 
# input trees are in same plot and ba is adjusted based on tpa:
sbal <- function(dbh, ba, spp, stat, sppref){
  sapply(dbh, function(x){
    index <- dbh > x & spp == sppref & stat == 1
    return(sum(ba[index]))
  })
}

sppbal <- lapply(levels(nf_trees$SPCD), function(i) {
  temp <- nf_trees %>% group_by(PLT_CN, SUBP) %>% 
    mutate(sppbal = sbal(DIA, 
                         ba_ac,
                         spp = SPCD, 
                         stat = STATUSCD, 
                         sppref = i)) %>% 
    ungroup()
  return(temp$sppbal)
})

temp <- as.data.frame(do.call(cbind, sppbal))
names(temp) <- str_replace(paste0("bal_", levels(nf_trees$SPCD)), " ", ".")
nf_trees <- cbind(nf_trees, temp)
```


```{r before_and_after}
################################################################################
# Combine FIA tables & reformat
################################################################################

# get before and after data and remeasurement period for each tree and -----
# add initial cond and plot data -------------------------------------------

nf_end <- nf_trees %>%
  left_join(nf_plots, by = "PLT_CN") %>%
  left_join(nf_conds, by = c("PLT_CN", "CONDID")) %>%
  rename(cn_e = CN, 
         plt_cn_e = PLT_CN, 
         condid_e = CONDID, 
         dbh_e = DIA, 
         statuscd_e = STATUSCD,
         mortyr_e = MORTYR, 
         cr_e = CR, 
         crown_class_e = CCLCD, 
         tree_class_e = TREECLCD, 
         MEASYEAR_E = MEASYEAR, 
         MEASMON_E = MEASMON, 
         MEASDAY_E = MEASDAY, 
         ba1_e = ba,
         bal1_e = bal, 
         ht_e = HT,
         forest_type_e = FORTYPCD, 
         stocking_e = ALSTKCD, 
         site_class_e = SITECLCD,
         landscape_e = PHYSCLCD, 
         slope_e = SLOPE, 
         aspect_e = ASPECT, 
         designcd_e = DESIGNCD) %>%
  select(-SPCD, -starts_with("ba_"), -starts_with("bal_"), -SUBP)

nf_start <- nf_trees %>%
  filter(CN %in% nf_end$PREV_TRE_CN) %>% 
  left_join(nf_plots, by = "PLT_CN") %>% 
  left_join(nf_conds, by = c("PLT_CN", "CONDID")) %>%
  rename(cn_s = CN, 
         plt_cn_s = PLT_CN, 
         condid_s = CONDID, 
         dbh_s = DIA, 
         statuscd_s = STATUSCD, 
         mortyr_s = MORTYR, 
         cr_s = CR, 
         crown_class_s = CCLCD, 
         tree_class_s = TREECLCD, 
         MEASYEAR_S = MEASYEAR, 
         MEASMON_S = MEASMON, 
         MEASDAY_S = MEASDAY, 
         ba1_s = ba, 
         bal1_s = bal, 
         ht_s = HT, 
         forest_type_s = FORTYPCD, 
         stocking_s = ALSTKCD, 
         site_class_s = SITECLCD,
         landscape_s = PHYSCLCD, 
         slope_s = SLOPE, 
         aspect_s = ASPECT, 
         designcd_s = DESIGNCD) %>%
  select(-PREV_TRE_CN, -PREV_PLT_CN, -LAT, -LON, -ELEV)

nf_fia <- nf_end %>%
  left_join(nf_start, by = c("PREV_TRE_CN" = "cn_s")) %>%
  filter(statuscd_s == 1, # only trees that started live
         statuscd_e != 0, # remove trees that were remeasured incorrectly
         cr_s >= 0,       # only trees that had cr at start 
         designcd_s == 1, # only those with current plot design 
         designcd_e == 1) %>%   
  mutate(MEASMON_E = formatC(MEASMON_E, width = 2, format = "d", flag = "0"), 
         MEASMON_S = formatC(MEASMON_S, width = 2, format = "d", flag = "0"),
         MEASDAY_E = formatC(MEASDAY_E, width = 2, format = "d", flag = "0"),
         MEASDAY_S = formatC(MEASDAY_S, width = 2, format = "d", flag = "0"),
         #make month and day codes 2 digits
         date_s = ymd(paste0(MEASYEAR_S, MEASMON_S, MEASDAY_S)),
         date_e = ymd(paste0(MEASYEAR_E, MEASMON_E, MEASDAY_E))) %>%
  # remove incorrectly entered dates (eg. Feb 31)
  filter(!is.na(date_e), !is.na(date_s)) %>% 
  mutate(interval = as.double(as.period(date_e - date_s), unit = "years"),
         cr_rate = (cr_e - cr_s)/interval,
         cr_mid = (cr_e + cr_s)/2,
         dbh_rate = (dbh_e - dbh_s)/interval,
         dbh_mid = (dbh_e + dbh_s)/2,
         ba1_mid = (ba1_e + ba1_s)/2,
         bal1_mid = (bal1_e + bal1_s)/2,
         ht_mid = (ht_e + ht_s)/2,
         ht_rate = (ht_e - ht_s)/interval,
         status_change = case_when(statuscd_e == 1 ~ "lived",
                                   statuscd_e == 2 ~ "died",
                                   statuscd_e == 3 ~ "cut",
                                   TRUE ~ "error"),
         status_change = as.factor(status_change),
         SPCD = as.factor(SPCD),
         plt_cn_e = as.factor(plt_cn_e)) %>%
  rename(ba1_ac = ba_ac) %>% 
  select(cn_e, spp = SPCD, dbh_e, dbh_rate, cr_s, cr_mid, 
         cr_e, cr_rate, crown_class_s, crown_class_e, tree_class_s, 
         tree_class_e, ba1_s, ba1_mid, ba1_e,
         bal1_s, bal1_mid, bal1_e, ht_s, ht_mid, ht_e, ht_rate,
         forest_type_s, forest_type_e, stocking_s, stocking_e, 
         landscape_s, landscape_e, site_class_s, site_class_e, 
         slope_s, slope_e, aspect_s, aspect_e, lat = LAT, lon = LON, 
         elev = ELEV, date_s, date_e, interval, status_change,
         plot = plt_cn_e, ba1_ac, plt_cn_s, SUBP,
         starts_with("ba_"), starts_with("bal_")) %>% 
  # mortality year was all null and was removed
  inner_join(nf_grms, by = c("cn_e" = "TRE_CN")) %>% 
  # use these dbh's b/c inconsistencies have been resolved (eg. measurements at different heights)
  rename(dbh_s = DIA_BEGIN, dbh_mid = DIA_MIDPT, 
         dbh_rate_fia = ANN_DIA_GROWTH, state = STATECD) 
  

remove(nf_start, nf_end, nf_conds, nf_plots, nf_trees, nf_grms, states, 
       VT_counties, NH_counties, NY_counties, ME_counties, pbal, state,
       sppba, sppbal, temp, species, species_codes, sbal)
```

We retained starting and ending values for variables that naturally change from one measurement to another, and calculated midpoint values for some variables by averaging the starting and ending values. Midpoint values were recorded to better reflect average conditions during the remeasurement period. 

Some of the ostensibly fixed variables like slope, aspect, and site class were found to change from one measurement to another in a minority of instances. For example, aspect was recorded differently in `r ifelse(round(100*sum(nf_fia$aspect_e != nf_fia$aspect_s, na.rm = T)/nrow(nf_fia)) >= 10,round(100*sum(nf_fia$aspect_e != nf_fia$aspect_s, na.rm = T)/nrow(nf_fia)), english::words(round(100*sum(nf_fia$aspect_e != nf_fia$aspect_s, na.rm = T)/nrow(nf_fia))))` percent of remeasurements, slope was recorded differently in `r ifelse(round(100*sum(nf_fia$slope_e != nf_fia$slope_s, na.rm = T)/nrow(nf_fia)) >= 10, round(100*sum(nf_fia$slope_e != nf_fia$slope_s, na.rm = T)/nrow(nf_fia)), english::words(round(100*sum(nf_fia$slope_e != nf_fia$slope_s, na.rm = T)/nrow(nf_fia))))` percent of remeasurements, and site class was recorded differently in `r ifelse(round(100*sum(nf_fia$site_class_e != nf_fia$site_class_s, na.rm = T)/nrow(nf_fia)) >= 10, round(100*sum(nf_fia$site_class_e != nf_fia$site_class_s, na.rm = T)/nrow(nf_fia)), english::words(round(100*sum(nf_fia$site_class_e != nf_fia$site_class_s, na.rm = T)/nrow(nf_fia))))` percent of remeasurements, despite the fact that they were measured on the same plots and should have remained constant. The differences between starting and ending values are generally small, however, and are probably measurement errors. In the case of slope, the mean absolute difference of deviating measurements is only `r ifelse(round(mean(abs(nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_e - nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_s), na.rm = T)) < 10, english::words(round(mean(abs(nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_e - nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_s), na.rm = T))), round(mean(abs(nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_e - nf_fia[nf_fia$slope_s != nf_fia$slope_e,]$slope_s), na.rm = T)))` percent. Among erroneous site class measures, the average is only `r ifelse(round(mean(abs(nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_e - nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_s), na.rm = T)) < 10, english::words(round(mean(abs(nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_e - nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_s), na.rm = T))), round(mean(abs(nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_e - nf_fia[nf_fia$site_class_s != nf_fia$site_class_e,]$site_class_s), na.rm = T)))` site class.  Aspect errors tend to be higher, averaging `r ifelse(round(mean(abs(nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_e - nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_s), na.rm = T)) >= 10, round(mean(abs(nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_e - nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_s), na.rm = T)), english::words(round(mean(abs(nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_e - nf_fia[nf_fia$aspect_s != nf_fia$aspect_e,]$aspect_s), na.rm = T))))` degrees, but they can be attributed to the difficulty of determining aspects in relatively flat terrain.  If only plots with slopes over 20 percent are considered, the mean absolute aspect error falls to `r ifelse(round(mean(abs(nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_e - nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_s), na.rm = T)) < 10, english::words(round(mean(abs(nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_e - nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_s), na.rm = T))), round(mean(abs(nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_e - nf_fia[nf_fia$aspect_e != nf_fia$aspect_s & nf_fia$slope_s > 20,]$aspect_s), na.rm = T)))` degrees. All these discontinuities were assumed to be random measurement errors, and starting values were arbitrarily retained in the dataset while ending values were discarded.

```{r fixed_vars}
# Keep starting values for fixed variables & ------------------------------
# only keep records with all neccessary fields ----------------------------

nf_fia <- nf_fia %>%
  rename(landscape = landscape_s,
         site_class = site_class_s,
         slope = slope_s,
         aspect = aspect_s) %>%
  select(-landscape_e, -site_class_e, -slope_e, -aspect_e) %>%
  filter(!is.na(spp), # only keep records with all neccessary fields
         !is.na(dbh_s), # could these affect some trees in a plot but not all?
         !is.na(crown_class_s),
         !is.na(tree_class_s),
         !is.na(ba1_s),
         !is.na(bal1_s),
         !is.na(forest_type_s),
         !is.na(forest_type_e),
         !is.na(stocking_s),
         !is.na(stocking_e),
         !is.na(landscape),
         !is.na(site_class),
         !is.na(slope),
         !is.na(aspect),
         !is.na(lat),
         !is.na(lon),
         !is.na(elev),
         !is.na(status_change),
         xor(is.na(bal1_e), status_change == "lived"))
```

We renamed the variables in the dataset and replaced FIA codes for the levels of categorical variables with descriptive strings, to make them more intuitive and user-friendly. We also grouped tree species into species groups and FIA forest types into more general forest types, so they match common inventory protocols. For example, most species in the genus *Populus* are combined into a single "aspen" group to make data collection easier, although cottonwoods (*Populus deltoides*) are kept in their own group because they exhibit very different growth characteristics. Similarly, the FIA forest types "balsam fir", "white spruce", "red spruce", "red spruce/balsam fir", and "black spruce" were combined into a single "Spruce-fir" group, but "northern white-cedar" was kept in its own "Cedar" group.

```{r categorical_levels}
################################################################################
# Make names and factor levels more intuitive 
################################################################################

# Forest types -----------------------------------------------------------------

forest_type_codes <- 
  c(101, 102, 103, 104, 105, 121, 122, 123, 124, 125, 126, 127, 
    167, 171, 381, 384, 385, 401, 402, 409, 503, 505, 509, 512, 
    513, 515, 516, 517, 519, 520, 701, 702, 703, 704, 705, 706, 
    707, 708, 709, 801, 802, 805, 809, 901, 902, 903, 904, 905, 
    962, 995, 999)

forest_types <- 
  c("Red pine", "Red pine", "White pine", "Mixed softwood", "Hemlock",
    "Spruce-fir", "Spruce-fir", "Spruce-fir", "Spruce-fir", "Spruce-fir",
    "Larch", "Cedar", "Mixed softwood", "Mixed softwood", "Scots pine", 
    "Norway spruce", "Larch", "Pine-hardwood", "Mixedwood",
    "Pine-hardwood", "Oak-hickory", "Oak-hickory", "Oak-hickory", 
    "Transition hardwood", "Transition hardwood", "Oak-hickory", 
    "Transition hardwood", "Transition hardwood", "Northern hardwood", 
    "Northern hardwood", "Northern hardwood", "Transition hardwood", 
    "Cottonwood", "Other", "Other", "Other", "Northern hardwood", 
    "Northern hardwood", "Cottonwood", "Northern hardwood", 
    "Northern hardwood", "Northern hardwood", "Northern hardwood", 
    "Northern hardwood", "Northern hardwood", "Northern hardwood", 
    "Northern hardwood", "Northern hardwood", "Other", "Other", 
    "Nonstocked")

names(forest_types) <- as.character(forest_type_codes)

nf_fia$forest_type_s <- 
  factor(unname(forest_types[as.character(nf_fia$forest_type_s)]),
         levels = levels(factor(forest_types)))

nf_fia$forest_type_e <- 
  factor(unname(forest_types[as.character(nf_fia$forest_type_e)]),
         levels = levels(factor(forest_types)))

# Landscapes -------------------------------------------------------------------

landscape_codes <- # add 19 & 33
  c(11, 12, 13, 19, 21, 22, 23, 24, 25, 29, 31, 32, 33, 34, 39)

landscapes <- 
  c("dry tops", "dry slopes", "deep sands", "other xeric", "flatwoods", 
    "rolling uplands", "moist slopes & coves", "narrow floodplains/bottomlands",
    "broad floodplains/bottomlands", "other mesic", "swamps/bogs", 
    "small drains", "small drains", "beaver ponds", "other hydric")

names(landscapes) <- as.character(landscape_codes)

nf_fia$landscape <- factor(unname(landscapes[as.character(nf_fia$landscape)]),
                           levels = levels(factor(landscapes)))
```

```{r save}
################################################################################
# Finish up
################################################################################

remove(forest_type_codes, forest_types, landscape_codes, landscapes)

# put columns in order
nf_fia <- nf_fia %>%
  select(spp, dbh_s, dbh_mid, dbh_e, dbh_rate, dbh_rate_fia, cr_s, cr_mid, 
         cr_e, cr_rate, crown_class_s, crown_class_e, tree_class_s, 
         tree_class_e, ba1_s, ba1_mid, ba1_e, bal1_s, bal1_mid, bal1_e, ht_s, 
         ht_mid, ht_e, ht_rate, forest_type_s, forest_type_e,
         stocking_s, stocking_e, landscape, site_class, slope, aspect,
         lat, lon, elev, state, date_s, date_e, interval, status_change,
         plot, ba1_ac, plt_cn_s, SUBP,
         starts_with("ba_"), starts_with("bal_")) %>% 
  rename(ba_s = ba1_s, ba_mid = ba1_mid, ba_e = ba1_e,
         bal_s = bal1_s, bal_mid = bal1_mid, bal_e = bal1_e,
         ba_ac = ba1_ac)


# Save ---------------------------------------------------------------------

save(nf_fia, file = "rda/nf-fia.rda")
```

# Organization

The final dataset contains `r format(nrow(nf_fia),big.mark=",")` unique tree records, which were tallied across `r format(length(unique(nf_fia$plot)),big.mark=",")` plots evenly distributed throughout the region. Tallied trees belong to `r length(unique(nf_fia$spp))` different species groups and were located in `r length(unique(c(nf_fia$forest_type_s,nf_fia$forest_type_e)))` different forest types in `r length(unique(nf_fia$landscape))` different physiographic (landscape) positions. Remeasurement periods ranged from `r round(min(nf_fia$interval),2)` to `r round(max(nf_fia$interval),2)` years and averaged `r round(mean(nf_fia$interval),2)` years. `r english::Words(round(100*nrow(dplyr::filter(nf_fia,status_change=="lived"))/nrow(nf_fia)))` percent of tallied trees lived through the remeasurement period and the remaining `r english::words(round(100*nrow(dplyr::filter(nf_fia,status_change=="died" | status_change=="cut"))/nrow(nf_fia)))` percent died.

A description of each variable in the final dataset and its source is provided below. Fields from the FIA database are referenced by their Oracle table and field names, in the form $TABLE\$FIELD$. Some of the variables account for more than one column in the dataset. Variable names amended with $\_s$ are measurements taken at the start of the remeasurement period; those amended with $\_e$ are measurements taken at the end of the remeasurement period; those amended with $\_mid$ are estimates of mid-period values, calculated by averaging the starting and ending measurements; and those amended with $\_rate$ are annual rates of change, averaged over the remeasurement period. Positive rates are increasing values, and negative rates are decreasing values.

__spp__   
\vspace{2pt}
Species or species group. Adapted from $TREE\$SPCD$.

__dbh__   
\vspace{2pt}
Diameter at breast height (4.5' above ground), measured in inches. From $TREE\$DIA$. Note that $dbh\_rate$ is calculated as $(dbh\_e - dbh\_s) / interval$ and is the preferred variable for model formulation. $dbh\_rate\_fia$ is from $TREE\_GRM\_COMPONENT\$ANN\_DIA\_GROWTH$ and is estimated using an existing diameter growth model. It is included for reference only and should not be used to train new models. 

__cr__   
\vspace{2pt}
Compacted crown ratio (percent of tree height supporting live crown). From $TREE\$CR$.

__crown_class__   
\vspace{2pt}
Tree canopy position. From $TREE\$CCLCD$:  
&nbsp;&nbsp;&nbsp;&nbsp;*1* Open grown (crown has received full light for most or all of its life)   
&nbsp;&nbsp;&nbsp;&nbsp;*2* Dominant (crown extends above main canopy and receives full light from above and partly from sides)   
&nbsp;&nbsp;&nbsp;&nbsp;*3* Codominant (crown in main canopy and receives full light from above, but little from sides)  
&nbsp;&nbsp;&nbsp;&nbsp;*4* Intermediate (crown extends into main canopy, but receives little direct light)    
&nbsp;&nbsp;&nbsp;&nbsp;*5* Overtopped (crown entirely below main canopy level, receiving no direct light)  

__tree_class__   
\vspace{2pt}
General quality of a live tree. From $TREE\$TREECLCD$:  
&nbsp;&nbsp;&nbsp;&nbsp;*2* Growing-stock (of commercial species and meeting minimum merchantability standards)  
&nbsp;&nbsp;&nbsp;&nbsp;*3* Rough-cull (sound wood, but does not meet minimum merchantability standards)  
&nbsp;&nbsp;&nbsp;&nbsp;*4* Rotten-cull (does not meet minimum merchantability standards and more than half of cull is rotten)  

__ba__  
\vspace{2pt}
Plot basal area, measured in square feet per acre of all live trees, 1" dbh or greater. Calculated by computing individual trees' per acre basal areas ($ba * tpa$), then summing those basal areas within subplots. Variables whose names end with a species name (such as $ba\_ash$) are plot basal areas of only the species indicated.

__bal__   
\vspace{2pt}
Overtopping basal area, measured in square feet per acre. Calculated by computing individual trees' per acre basal areas ($ba * tpa$), then for each tree summing the per acre basal areas of other trees in in the same subplot with larger diameters. Variables whose names end with a species name (such as $bal\_ash$) are overtopping basal areas that only account for overtopping trees of the species indicated.

__ht__   
\vspace{2pt}
Total tree height, measured in feet. From $TREE\$HT$. For trees with broken tops, heights are estimated by FIA program. 

__forest_type__   
\vspace{2pt}
Forest type defined by the species dominating stocking. Adapted from $COND\$FORTYPCD$. Note that FIA does not recognize a "mixedwood" forest type, so plots with greater than half of their basal area in softwood species are generally considered softwood types, and those with greater than half of their stocking in hardwoods are considered hardwood types. The exceptions are the "Pine-hardwood" and "Cedar-hardwood" types. The forest types used here do not always coincide well with available stocking charts. Types in the Northern Forest region include:   
&nbsp;&nbsp;&nbsp;&nbsp;*Northern hardwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Transition hardwood*    
&nbsp;&nbsp;&nbsp;&nbsp;*Oak-hickory*  
&nbsp;&nbsp;&nbsp;&nbsp;*Cottonwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Pine-hardwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Cedar-hardwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Spruce-fir*  
&nbsp;&nbsp;&nbsp;&nbsp;*Cedar*  
&nbsp;&nbsp;&nbsp;&nbsp;*Hemlock*  
&nbsp;&nbsp;&nbsp;&nbsp;*Larch* (includes tamarack)  
&nbsp;&nbsp;&nbsp;&nbsp;*Norway spruce*  
&nbsp;&nbsp;&nbsp;&nbsp;*White pine*  
&nbsp;&nbsp;&nbsp;&nbsp;*Red pine*  
&nbsp;&nbsp;&nbsp;&nbsp;*Scots pine*  
&nbsp;&nbsp;&nbsp;&nbsp;*Mixed softwood*  
&nbsp;&nbsp;&nbsp;&nbsp;*Other*  
&nbsp;&nbsp;&nbsp;&nbsp;*Nonstocked*  

__stocking__  
\vspace{2pt}
Plot-level stocking of all live trees 1" dbh and larger. From $COND\$ALSTKCD$:  
&nbsp;&nbsp;&nbsp;&nbsp;*1* Overstocked   
&nbsp;&nbsp;&nbsp;&nbsp;*2* Fully stocked   
&nbsp;&nbsp;&nbsp;&nbsp;*3* Medium stocked  
&nbsp;&nbsp;&nbsp;&nbsp;*4* Poorly stocked    
&nbsp;&nbsp;&nbsp;&nbsp;*5* Nonstocked   

__landscape__  
\vspace{2pt}
Physiography. From $COND\$PHYSCLCD$. Depends on land form, topographic position, and soil type.  Classes include:   
&nbsp;&nbsp;&nbsp;&nbsp;*dry tops*  
&nbsp;&nbsp;&nbsp;&nbsp;*dry slopes*  
&nbsp;&nbsp;&nbsp;&nbsp;*deep sands*  
&nbsp;&nbsp;&nbsp;&nbsp;*other xeric*  
&nbsp;&nbsp;&nbsp;&nbsp;*flatwoods*  
&nbsp;&nbsp;&nbsp;&nbsp;*rolling uplands*  
&nbsp;&nbsp;&nbsp;&nbsp;*moist slopes & coves*  
&nbsp;&nbsp;&nbsp;&nbsp;*narrow floodplains/bottomlands*  
&nbsp;&nbsp;&nbsp;&nbsp;*broad floodplains/bottomlands*  
&nbsp;&nbsp;&nbsp;&nbsp;*other mesic*  
&nbsp;&nbsp;&nbsp;&nbsp;*swamps/bogs*  
&nbsp;&nbsp;&nbsp;&nbsp;*small drains*  
&nbsp;&nbsp;&nbsp;&nbsp;*beaver ponds*  
&nbsp;&nbsp;&nbsp;&nbsp;*other hydric*  

__site_class__  
\vspace{2pt}
Site productivity class. From $COND\$SITECLCD$. Defined by potential wood growth in cubic feet per acre per year:   
&nbsp;&nbsp;&nbsp;&nbsp;*1* 225+ ft^3^ac^-1^yr^-1^  
&nbsp;&nbsp;&nbsp;&nbsp;*2* 165-224 ft^3^ac^-1^yr^-1^   
&nbsp;&nbsp;&nbsp;&nbsp;*3* 120-164 ft^3^ac^-1^yr^-1^   
&nbsp;&nbsp;&nbsp;&nbsp;*4* 85-119 ft^3^ac^-1^yr^-1^ (equivalent to class I in VT)     
&nbsp;&nbsp;&nbsp;&nbsp;*5* 50-84 ft^3^ac^-1^yr^-1^ (equivalent to class II in VT)  
&nbsp;&nbsp;&nbsp;&nbsp;*6* 20-49 ft^3^ac^-1^yr^-1^ (equivalent to class III in VT)     
&nbsp;&nbsp;&nbsp;&nbsp;*7* 0-19 ft^3^ac^-1^yr^-1^ (equivalent to class IV in VT)  

__slope__  
\vspace{2pt}
Slope in percent. From $COND\$SLOPE$.

__aspect__  
\vspace{2pt}
Aspect in degrees. From $COND\$ASPECT$.

__lat__  
\vspace{2pt}
Plot latitude in decimal degrees (random offset is applied to protect landowners' privacy). From $PLOT\$LAT$.

__lon__  
\vspace{2pt}
Plot longitude in decimal degrees (random offset is applied to protect landowners' privacy). From $PLOT\$LON$.

__elev__  
\vspace{2pt}
Plot elevation in feet above mean sea level. From $PLOT\$ELEV$.

__date__  
\vspace{2pt}
Inventory date. Calculated from $PLOT\$MEASYEAR$, $PLOT\$MEASMON$, and $PLOT\$MEASDAY$.

__interval__  
\vspace{2pt}
Length of remeasurement period in years. Calculated as $date\_e - date\_s$.

__status_change__  
\vspace{2pt}
Change in tree status during remeasurement period. Based on $TREE\$STATUSCD$. One of:   
&nbsp;&nbsp;&nbsp;&nbsp;*lived*  
&nbsp;&nbsp;&nbsp;&nbsp;*died* (natural mortality)  
&nbsp;&nbsp;&nbsp;&nbsp;*cut*  

__plot__  
\vspace{2pt}
A unique identifier for the plot the tree was recorded on. Corresponds to $PLOT\$CN$ attribute for the ending inventory. 
